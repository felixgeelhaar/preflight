package security

import (
	"fmt"
	"strings"
	"time"
)

// Vulnerability represents a security vulnerability in a package.
type Vulnerability struct {
	// ID is the vulnerability identifier (e.g., CVE-2024-1234).
	ID string

	// Package is the name of the affected package.
	Package string

	// Version is the installed version of the package.
	Version string

	// Severity is the severity level of the vulnerability.
	Severity Severity

	// CVSS is the CVSS score (0.0-10.0) if available.
	CVSS float64

	// Title is a short description of the vulnerability.
	Title string

	// Description is a detailed description of the vulnerability.
	Description string

	// FixedIn is the version that fixes this vulnerability (empty if no fix).
	FixedIn string

	// Reference is a URL to the vulnerability details.
	Reference string

	// Provider is the package manager (e.g., "brew", "apt").
	Provider string

	// DetectedAt is when the vulnerability was detected.
	DetectedAt time.Time
}

// VulnerabilityBuilder builds Vulnerability instances.
type VulnerabilityBuilder struct {
	v Vulnerability
}

// NewVulnerability creates a new VulnerabilityBuilder.
func NewVulnerability(id, pkg string) *VulnerabilityBuilder {
	return &VulnerabilityBuilder{
		v: Vulnerability{
			ID:         id,
			Package:    pkg,
			Severity:   SeverityUnknown,
			DetectedAt: time.Now(),
		},
	}
}

// WithVersion sets the package version.
func (b *VulnerabilityBuilder) WithVersion(version string) *VulnerabilityBuilder {
	b.v.Version = version
	return b
}

// WithSeverity sets the severity level.
func (b *VulnerabilityBuilder) WithSeverity(severity Severity) *VulnerabilityBuilder {
	b.v.Severity = severity
	return b
}

// WithCVSS sets the CVSS score.
func (b *VulnerabilityBuilder) WithCVSS(cvss float64) *VulnerabilityBuilder {
	b.v.CVSS = cvss
	return b
}

// WithTitle sets the vulnerability title.
func (b *VulnerabilityBuilder) WithTitle(title string) *VulnerabilityBuilder {
	b.v.Title = title
	return b
}

// WithDescription sets the vulnerability description.
func (b *VulnerabilityBuilder) WithDescription(desc string) *VulnerabilityBuilder {
	b.v.Description = desc
	return b
}

// WithFixedIn sets the fixed version.
func (b *VulnerabilityBuilder) WithFixedIn(version string) *VulnerabilityBuilder {
	b.v.FixedIn = version
	return b
}

// WithReference sets the reference URL.
func (b *VulnerabilityBuilder) WithReference(url string) *VulnerabilityBuilder {
	b.v.Reference = url
	return b
}

// WithProvider sets the package provider.
func (b *VulnerabilityBuilder) WithProvider(provider string) *VulnerabilityBuilder {
	b.v.Provider = provider
	return b
}

// Build creates the Vulnerability instance.
func (b *VulnerabilityBuilder) Build() Vulnerability {
	return b.v
}

// HasFix returns true if there's a known fix version.
func (v Vulnerability) HasFix() bool {
	return v.FixedIn != ""
}

// IsCriticalOrHigh returns true if severity is critical or high.
func (v Vulnerability) IsCriticalOrHigh() bool {
	return v.Severity == SeverityCritical || v.Severity == SeverityHigh
}

// Summary returns a one-line summary of the vulnerability.
func (v Vulnerability) Summary() string {
	var parts []string
	parts = append(parts, v.ID)

	if v.Package != "" {
		pkgInfo := v.Package
		if v.Version != "" {
			pkgInfo = fmt.Sprintf("%s@%s", v.Package, v.Version)
		}
		parts = append(parts, pkgInfo)
	}

	parts = append(parts, fmt.Sprintf("(%s)", v.Severity))

	if v.Title != "" {
		parts = append(parts, v.Title)
	}

	return strings.Join(parts, " ")
}

// NVDLink returns the NVD link for CVE IDs.
func (v Vulnerability) NVDLink() string {
	if strings.HasPrefix(strings.ToUpper(v.ID), "CVE-") {
		return fmt.Sprintf("https://nvd.nist.gov/vuln/detail/%s", v.ID)
	}
	return v.Reference
}

// Vulnerabilities is a collection of vulnerabilities with helper methods.
type Vulnerabilities []Vulnerability

// BySeverity returns vulnerabilities filtered by minimum severity.
func (vs Vulnerabilities) BySeverity(minSeverity Severity) Vulnerabilities {
	result := make(Vulnerabilities, 0)
	for _, v := range vs {
		if v.Severity.IsAtLeast(minSeverity) {
			result = append(result, v)
		}
	}
	return result
}

// Critical returns only critical vulnerabilities.
func (vs Vulnerabilities) Critical() Vulnerabilities {
	return vs.BySeverity(SeverityCritical)
}

// High returns high and above vulnerabilities.
func (vs Vulnerabilities) High() Vulnerabilities {
	return vs.BySeverity(SeverityHigh)
}

// CountBySeverity returns counts for each severity level.
func (vs Vulnerabilities) CountBySeverity() map[Severity]int {
	counts := make(map[Severity]int)
	for _, v := range vs {
		counts[v.Severity]++
	}
	return counts
}

// HasCritical returns true if there are any critical vulnerabilities.
func (vs Vulnerabilities) HasCritical() bool {
	for _, v := range vs {
		if v.Severity == SeverityCritical {
			return true
		}
	}
	return false
}

// Fixable returns vulnerabilities that have a known fix.
func (vs Vulnerabilities) Fixable() Vulnerabilities {
	result := make(Vulnerabilities, 0)
	for _, v := range vs {
		if v.HasFix() {
			result = append(result, v)
		}
	}
	return result
}

// ByPackage groups vulnerabilities by package name.
func (vs Vulnerabilities) ByPackage() map[string]Vulnerabilities {
	result := make(map[string]Vulnerabilities)
	for _, v := range vs {
		result[v.Package] = append(result[v.Package], v)
	}
	return result
}

// ExcludeIDs filters out vulnerabilities with the given IDs.
func (vs Vulnerabilities) ExcludeIDs(ids []string) Vulnerabilities {
	if len(ids) == 0 {
		return vs
	}

	exclude := make(map[string]bool, len(ids))
	for _, id := range ids {
		exclude[strings.ToUpper(id)] = true
	}

	result := make(Vulnerabilities, 0, len(vs))
	for _, v := range vs {
		if !exclude[strings.ToUpper(v.ID)] {
			result = append(result, v)
		}
	}
	return result
}
