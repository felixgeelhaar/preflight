package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/felixgeelhaar/preflight/internal/app"
	"github.com/pelletier/go-toml/v2"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

var exportCmd = &cobra.Command{
	Use:   "export",
	Short: "Export configuration in different formats",
	Long: `Export your preflight configuration to various formats for portability.

Supported formats:
  - yaml (default): Standard YAML output
  - json: JSON format for programmatic consumption
  - toml: TOML format for compatibility with other tools
  - nix: Nix expression for home-manager integration
  - brewfile: Homebrew Brewfile format
  - shell: Shell script for portable execution

The export merges all layers for the specified target into a single
output, making it easy to share or migrate configurations.

Examples:
  preflight export                      # Export as YAML to stdout
  preflight export --format json        # Export as JSON
  preflight export --format nix -o home.nix
  preflight export --format brewfile -o Brewfile
  preflight export --target work --format shell`,
	RunE: runExport,
}

var (
	exportConfigPath string
	exportTarget     string
	exportFormat     string
	exportOutput     string
	exportFlattened  bool
)

func init() {
	rootCmd.AddCommand(exportCmd)

	exportCmd.Flags().StringVarP(&exportConfigPath, "config", "c", "preflight.yaml", "Path to preflight.yaml")
	exportCmd.Flags().StringVarP(&exportTarget, "target", "t", "default", "Target to export")
	exportCmd.Flags().StringVarP(&exportFormat, "format", "f", "yaml", "Output format (yaml, json, toml, nix, brewfile, shell)")
	exportCmd.Flags().StringVarP(&exportOutput, "output", "o", "", "Output file (default: stdout)")
	exportCmd.Flags().BoolVar(&exportFlattened, "flatten", false, "Flatten all layers into single config")
}

func runExport(_ *cobra.Command, _ []string) error {
	ctx := context.Background()

	preflight := app.New(os.Stdout)

	// Load and merge configuration
	merged, err := preflight.LoadMergedConfig(ctx, exportConfigPath, exportTarget)
	if err != nil {
		return fmt.Errorf("failed to load configuration: %w", err)
	}

	// Convert to export format
	var output []byte
	switch strings.ToLower(exportFormat) {
	case "yaml", "yml":
		output, err = yaml.Marshal(merged)
	case "json":
		output, err = json.MarshalIndent(merged, "", "  ")
	case "toml":
		output, err = toml.Marshal(merged)
	case "nix":
		output, err = exportToNix(merged)
	case "brewfile":
		output, err = exportToBrewfile(merged)
	case "shell", "sh", "bash":
		output, err = exportToShell(merged)
	default:
		return fmt.Errorf("unsupported format: %s", exportFormat)
	}

	if err != nil {
		return fmt.Errorf("failed to export: %w", err)
	}

	// Write output
	if exportOutput != "" {
		dir := filepath.Dir(exportOutput)
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}
		if err := os.WriteFile(exportOutput, output, 0o644); err != nil {
			return fmt.Errorf("failed to write file: %w", err)
		}
		fmt.Printf("Exported to %s\n", exportOutput)
	} else {
		fmt.Print(string(output))
	}

	return nil
}

//nolint:gocritic,unparam // sprintfQuotedString: literal quotes needed for Nix syntax; error return for future implementation
func exportToNix(config map[string]interface{}) ([]byte, error) {
	var sb strings.Builder

	sb.WriteString("# Generated by preflight export\n")
	sb.WriteString("# https://github.com/felixgeelhaar/preflight\n\n")
	sb.WriteString("{ config, pkgs, ... }:\n\n")
	sb.WriteString("{\n")

	// Export homebrew packages as nix packages
	if brew, ok := config["brew"].(map[string]interface{}); ok {
		if formulae, ok := brew["formulae"].([]interface{}); ok && len(formulae) > 0 {
			sb.WriteString("  home.packages = with pkgs; [\n")
			for _, f := range formulae {
				if name, ok := f.(string); ok {
					// Convert brew name to nix package name (best effort)
					nixName := strings.ReplaceAll(name, "-", "")
					sb.WriteString(fmt.Sprintf("    %s\n", nixName))
				}
			}
			sb.WriteString("  ];\n\n")
		}
	}

	// Export git configuration
	if git, ok := config["git"].(map[string]interface{}); ok {
		sb.WriteString("  programs.git = {\n")
		sb.WriteString("    enable = true;\n")
		if name, ok := git["name"].(string); ok {
			sb.WriteString(fmt.Sprintf("    userName = \"%s\";\n", name))
		}
		if email, ok := git["email"].(string); ok {
			sb.WriteString(fmt.Sprintf("    userEmail = \"%s\";\n", email))
		}
		sb.WriteString("  };\n\n")
	}

	// Export shell configuration
	if shell, ok := config["shell"].(map[string]interface{}); ok {
		if shellType, ok := shell["shell"].(string); ok && shellType == "zsh" {
			sb.WriteString("  programs.zsh = {\n")
			sb.WriteString("    enable = true;\n")
			if plugins, ok := shell["plugins"].([]interface{}); ok {
				sb.WriteString("    plugins = [\n")
				for _, p := range plugins {
					if name, ok := p.(string); ok {
						sb.WriteString(fmt.Sprintf("      { name = \"%s\"; }\n", name))
					}
				}
				sb.WriteString("    ];\n")
			}
			sb.WriteString("  };\n\n")
		}
	}

	sb.WriteString("}\n")

	return []byte(sb.String()), nil
}

//nolint:gocritic,unparam // sprintfQuotedString: literal quotes needed for Brewfile syntax; error return for future implementation
func exportToBrewfile(config map[string]interface{}) ([]byte, error) {
	var sb strings.Builder

	sb.WriteString("# Generated by preflight export\n")
	sb.WriteString("# https://github.com/felixgeelhaar/preflight\n\n")

	if brew, ok := config["brew"].(map[string]interface{}); ok {
		// Taps
		if taps, ok := brew["taps"].([]interface{}); ok {
			for _, t := range taps {
				if name, ok := t.(string); ok {
					sb.WriteString(fmt.Sprintf("tap \"%s\"\n", name))
				}
			}
			if len(taps) > 0 {
				sb.WriteString("\n")
			}
		}

		// Formulae
		if formulae, ok := brew["formulae"].([]interface{}); ok {
			for _, f := range formulae {
				if name, ok := f.(string); ok {
					sb.WriteString(fmt.Sprintf("brew \"%s\"\n", name))
				}
			}
			if len(formulae) > 0 {
				sb.WriteString("\n")
			}
		}

		// Casks
		if casks, ok := brew["casks"].([]interface{}); ok {
			for _, c := range casks {
				if name, ok := c.(string); ok {
					sb.WriteString(fmt.Sprintf("cask \"%s\"\n", name))
				}
			}
		}
	}

	return []byte(sb.String()), nil
}

//nolint:gocritic,unparam // sprintfQuotedString: literal quotes needed for shell syntax; error return for future implementation
func exportToShell(config map[string]interface{}) ([]byte, error) {
	var sb strings.Builder

	sb.WriteString("#!/usr/bin/env bash\n")
	sb.WriteString("# Generated by preflight export\n")
	sb.WriteString("# https://github.com/felixgeelhaar/preflight\n\n")
	sb.WriteString("set -euo pipefail\n\n")

	// Homebrew installation check
	sb.WriteString("# Ensure Homebrew is installed\n")
	sb.WriteString("if ! command -v brew &> /dev/null; then\n")
	sb.WriteString("  echo \"Installing Homebrew...\"\n")
	sb.WriteString("  /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n")
	sb.WriteString("fi\n\n")

	if brew, ok := config["brew"].(map[string]interface{}); ok {
		// Taps
		if taps, ok := brew["taps"].([]interface{}); ok && len(taps) > 0 {
			sb.WriteString("# Add taps\n")
			for _, t := range taps {
				if name, ok := t.(string); ok {
					sb.WriteString(fmt.Sprintf("brew tap %s\n", name))
				}
			}
			sb.WriteString("\n")
		}

		// Formulae
		if formulae, ok := brew["formulae"].([]interface{}); ok && len(formulae) > 0 {
			sb.WriteString("# Install formulae\n")
			sb.WriteString("brew install \\\n")
			for i, f := range formulae {
				if name, ok := f.(string); ok {
					if i < len(formulae)-1 {
						sb.WriteString(fmt.Sprintf("  %s \\\n", name))
					} else {
						sb.WriteString(fmt.Sprintf("  %s\n", name))
					}
				}
			}
			sb.WriteString("\n")
		}

		// Casks
		if casks, ok := brew["casks"].([]interface{}); ok && len(casks) > 0 {
			sb.WriteString("# Install casks\n")
			sb.WriteString("brew install --cask \\\n")
			for i, c := range casks {
				if name, ok := c.(string); ok {
					if i < len(casks)-1 {
						sb.WriteString(fmt.Sprintf("  %s \\\n", name))
					} else {
						sb.WriteString(fmt.Sprintf("  %s\n", name))
					}
				}
			}
			sb.WriteString("\n")
		}
	}

	// Git configuration
	if git, ok := config["git"].(map[string]interface{}); ok {
		sb.WriteString("# Configure git\n")
		if name, ok := git["name"].(string); ok {
			sb.WriteString(fmt.Sprintf("git config --global user.name \"%s\"\n", name))
		}
		if email, ok := git["email"].(string); ok {
			sb.WriteString(fmt.Sprintf("git config --global user.email \"%s\"\n", email))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("echo \"Setup complete!\"\n")

	return []byte(sb.String()), nil
}
